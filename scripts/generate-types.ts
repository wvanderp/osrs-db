#!/usr/bin/env tsx

/**
 * üéØ Generate a single types/index.d.ts for JSON subpath imports
 * 
 * This script discovers JSON data files and their schemas, then emits one
 * types/index.d.ts containing explicit `declare module "pkg/subpath.json"` blocks
 * for each JSON file.
 */

import { promises as fs } from 'node:fs';
import path from 'path';
import { glob } from 'glob';
import { yellow, green, red, cyan } from '../common/colors.js';

type JSONSchema = Record<string, any>;

interface DataFileEntry {
    jsonRel: string;          // Relative path from repo root
    jsonAbs: string;          // Absolute path
    schemaAbs?: string;       // Absolute path to schema
    typeName: string;         // PascalCase type name
    moduleId: string;         // Full module identifier (e.g., "osrs-db/data/items.g.json")
}

/**
 * Main entry point
 */
async function main() {
    const repoRoot = process.cwd();
    const pkgPath = path.join(repoRoot, 'package.json');
    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf8'));
    const packageName = pkg.name;

    console.log(green('üîß [generate-types] Starting type generation...'));
    console.log(cyan(`üì¶ [generate-types] Package: ${packageName}`));

    // 1) Discover data files
    const dataFiles = await glob(
        ['data/**/*.json', '!**/*.tmp.json', '!**/*.test.json', '!**/__snapshots__/**'],
        { cwd: repoRoot, dot: false, absolute: false, posix: true }
    );
    dataFiles.sort((a, b) => a.localeCompare(b));

    console.log(cyan(`üìã [generate-types] Found ${dataFiles.length} data files`));

    // 2) Map each data file to its schema and build entries
    const entries: DataFileEntry[] = [];
    let missingSchemaCount = 0;

    for (const rel of dataFiles) {
        const jsonAbs = path.join(repoRoot, rel);
        const schemaAbs = await findSchemaFor(jsonAbs, repoRoot);

        if (!schemaAbs) {
            console.log(yellow(`‚ö†Ô∏è  [generate-types] No schema found for ${rel}`));
            missingSchemaCount++;
        }

        const schemaTitle = schemaAbs ? await readSchemaTitle(schemaAbs) : undefined;
        const typeName = guessTypeNameFrom(rel, schemaTitle);
        const moduleId = `${packageName}/${rel.replace(/\\/g, '/')}`;

        entries.push({ jsonRel: rel, jsonAbs, schemaAbs, typeName, moduleId });
    }

    // 3) Build module blocks
    const blocks: string[] = [];
    let unknownCount = 0;

    for (const entry of entries) {
        const block = await buildModuleBlock(entry, repoRoot);
        blocks.push(block);
        if (!entry.schemaAbs) {
            unknownCount++;
        }
    }

    // 4) Assemble types/index.d.ts
    const header = [
        '// AUTO-GENERATED FILE. DO NOT EDIT.',
        '// Generated by: npm tsx scripts/generate-types.ts',
        '',
        '// This file provides TypeScript definitions for JSON data imports.',
        '// Consumers must have "resolveJsonModule": true in their tsconfig.json',
        '',
    ].join('\n');

    const content = header + blocks.join('\n\n') + '\n';
    const outPath = path.join(repoRoot, 'types', 'index.d.ts');

    await fs.mkdir(path.dirname(outPath), { recursive: true });

    // Only write if content changed
    const prev = await fs.readFile(outPath, 'utf8').catch(() => '');
    if (prev !== content) {
        await fs.writeFile(outPath, content, 'utf8');
        console.log(green(`‚úÖ [generate-types] Updated ${path.relative(repoRoot, outPath)}`));
    } else {
        console.log(cyan(`‚úì  [generate-types] No changes to ${path.relative(repoRoot, outPath)}`));
    }

    // 5) Update package.json
    await patchPackageJson(pkg, pkgPath, repoRoot);

    // 6) Print summary
    console.log('');
    console.log(green('‚ú® [generate-types] Type generation complete!'));
    console.log(cyan(`   üìÑ Generated ${entries.length} module blocks`));
    console.log(cyan(`   ‚úÖ With schema: ${entries.length - unknownCount}`));
    if (unknownCount > 0) {
        console.log(yellow(`   ‚ö†Ô∏è  Without schema (unknown): ${unknownCount}`));
    }
}

/**
 * Find the schema file for a given JSON data file
 * 
 * Strategy:
 * 1. Check same directory for {basename}.schema.json
 * 2. Check parent tool directory for {tool}.schema.json
 * 3. Return undefined if not found
 */
async function findSchemaFor(jsonAbs: string, repoRoot: string): Promise<string | undefined> {
    const dir = path.dirname(jsonAbs);
    const basename = path.basename(jsonAbs, '.json');

    // Strategy 1: Same directory - {basename}.schema.json
    const sameDir = path.join(dir, `${basename}.schema.json`);
    if (await fileExists(sameDir)) {
        return sameDir;
    }

    // Strategy 2: Check if we're in tools/{ToolName}/data/ structure
    // Look for tools/{ToolName}/{tool}.schema.json
    const relativePath = path.relative(repoRoot, jsonAbs);
    const parts = relativePath.split(path.sep);

    // For data/*.g.json files, check tools/{ToolName}/{name}.schema.json
    if (parts[0] === 'data') {
        const name = basename.replace(/\.g$/, ''); // Remove .g suffix

        // Try to find matching tool schema
        const toolsDir = path.join(repoRoot, 'tools');
        try {
            const tools = await fs.readdir(toolsDir);
            for (const tool of tools) {
                const toolSchemaPath = path.join(toolsDir, tool, `${name}.schema.json`);
                if (await fileExists(toolSchemaPath)) {
                    return toolSchemaPath;
                }
            }
        } catch {
            // toolsDir doesn't exist or can't read
        }
    }

    // For files in tools/{Tool}/data/*.json, look in parent
    if (parts[0] === 'tools' && parts.length >= 3) {
        const toolName = parts[1];
        const toolDir = path.join(repoRoot, 'tools', toolName);

        // Try exact match first
        const schemaPath = path.join(toolDir, `${basename}.schema.json`);
        if (await fileExists(schemaPath)) {
            return schemaPath;
        }

        // Try lowercase tool name
        const toolLower = toolName.toLowerCase();
        const toolSchema = path.join(toolDir, `${toolLower}.schema.json`);
        if (await fileExists(toolSchema)) {
            return toolSchema;
        }
    }

    return undefined;
}

/**
 * Check if a file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
    try {
        await fs.access(filePath);
        return true;
    } catch {
        return false;
    }
}

/**
 * Read the title from a JSON schema
 */
async function readSchemaTitle(schemaPath: string): Promise<string | undefined> {
    try {
        const content = await fs.readFile(schemaPath, 'utf8');
        const schema = JSON.parse(content);
        return schema.title;
    } catch {
        return undefined;
    }
}

/**
 * Guess a PascalCase type name from file path and schema title
 */
function guessTypeNameFrom(jsonRel: string, schemaTitle?: string): string {
    if (schemaTitle) {
        return toPascal(schemaTitle);
    }

    const base = path.basename(jsonRel, '.json');
    return toPascal(base);
}

/**
 * Convert a string to PascalCase
 */
function toPascal(s: string): string {
    return s
        .replace(/[^a-zA-Z0-9]+/g, ' ')
        .split(' ')
        .filter(Boolean)
        .map(part => part[0].toUpperCase() + part.slice(1).toLowerCase())
        .join('');
}

/**
 * Build a module declaration block for a data file
 */
async function buildModuleBlock(entry: DataFileEntry, repoRoot: string): Promise<string> {
    const lines: string[] = [];

    lines.push(`declare module "${entry.moduleId}" {`);

    // Add JSDoc comment about schema
    if (entry.schemaAbs) {
        const schemaRel = path.relative(repoRoot, entry.schemaAbs).replace(/\\/g, '/');
        lines.push(`  /** Generated from schema: ${schemaRel} */`);
    } else {
        lines.push(`  /** No schema found - type is unknown */`);
    }

    if (entry.schemaAbs) {
        try {
            const schemaContent = await fs.readFile(entry.schemaAbs, 'utf8');
            const schema: JSONSchema = JSON.parse(schemaContent);

            // Generate type from schema
            const typeInfo = schemaToTsType(schema, entry.typeName);

            // Add the type alias
            lines.push(`  ${typeInfo.typeDeclaration}`);
            lines.push('');

            // Add the default export
            lines.push(`  ${typeInfo.exportDeclaration}`);

        } catch (error) {
            // Fallback to unknown on error
            lines.push(`  export type ${entry.typeName} = unknown;`);
            lines.push('');
            lines.push(`  const data: unknown;`);
        }
    } else {
        // No schema - use unknown
        lines.push(`  export type ${entry.typeName} = unknown;`);
        lines.push('');
        lines.push(`  const data: unknown;`);
    }

    lines.push('  export default data;');
    lines.push('}');

    return lines.join('\n');
}

/**
 * Convert a JSON schema to TypeScript type declaration
 */
function schemaToTsType(schema: JSONSchema, typeName: string): { typeDeclaration: string; exportDeclaration: string } {
    const isArray = schema.type === 'array';
    const isObject = schema.type === 'object' || (schema.properties && !schema.type);

    if (isArray && schema.items) {
        // Array type
        const itemType = jsonSchemaTypeToTs(schema.items, `${typeName}Item`);
        const typeDeclaration = `export type ${typeName} = ${itemType};`;
        const exportDeclaration = `const data: ReadonlyArray<${typeName}>;`;
        return { typeDeclaration, exportDeclaration };
    } else if (isObject) {
        // Object type
        const objType = jsonSchemaTypeToTs(schema, typeName);
        const typeDeclaration = `export type ${typeName} = ${objType};`;
        const exportDeclaration = `const data: Readonly<${typeName}>;`;
        return { typeDeclaration, exportDeclaration };
    } else {
        // Primitive or other
        const tsType = jsonSchemaTypeToTs(schema, typeName);
        const typeDeclaration = `export type ${typeName} = ${tsType};`;
        const exportDeclaration = `const data: ${typeName};`;
        return { typeDeclaration, exportDeclaration };
    }
}

/**
 * Convert JSON schema type to TypeScript type string
 */
function jsonSchemaTypeToTs(schema: JSONSchema, fallbackName: string): string {
    // Handle $ref (basic support)
    if (schema.$ref) {
        return 'any'; // Simplified - proper $ref resolution would be more complex
    }

    // Handle const
    if (schema.const !== undefined) {
        return JSON.stringify(schema.const);
    }

    // Handle enum
    if (schema.enum) {
        return schema.enum.map((v: any) => JSON.stringify(v)).join(' | ');
    }

    // Handle oneOf/anyOf
    if (schema.oneOf) {
        return schema.oneOf.map((s: JSONSchema, i: number) =>
            jsonSchemaTypeToTs(s, `${fallbackName}Option${i}`)
        ).join(' | ');
    }
    if (schema.anyOf) {
        return schema.anyOf.map((s: JSONSchema, i: number) =>
            jsonSchemaTypeToTs(s, `${fallbackName}Option${i}`)
        ).join(' | ');
    }

    // Handle allOf (intersection)
    if (schema.allOf) {
        return schema.allOf.map((s: JSONSchema, i: number) =>
            `(${jsonSchemaTypeToTs(s, `${fallbackName}Part${i}`)})`
        ).join(' & ');
    }

    // Handle type array (union of types)
    if (Array.isArray(schema.type)) {
        return schema.type.map(t => primitiveTypeToTs(t)).join(' | ');
    }

    // Handle single type
    const type = schema.type as string;

    if (type === 'array') {
        const itemType = schema.items
            ? jsonSchemaTypeToTs(schema.items, `${fallbackName}Item`)
            : 'unknown';
        return `ReadonlyArray<${itemType}>`;
    }

    if (type === 'object' || schema.properties) {
        const props: string[] = [];
        const required = new Set(schema.required || []);

        if (schema.properties) {
            for (const [key, propSchema] of Object.entries(schema.properties)) {
                const propType = jsonSchemaTypeToTs(propSchema as JSONSchema, `${fallbackName}${toPascal(key)}`);
                const optional = required.has(key) ? '' : '?';
                const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
                props.push(`readonly ${safeKey}${optional}: ${propType}`);
            }
        }

        // Handle additionalProperties
        if (schema.additionalProperties === true) {
            props.push('readonly [key: string]: unknown');
        } else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
            const addType = jsonSchemaTypeToTs(schema.additionalProperties, `${fallbackName}Additional`);
            props.push(`readonly [key: string]: ${addType}`);
        }

        if (props.length === 0) {
            return 'Record<string, never>';
        }

        return `{\n    ${props.join(';\n    ')};\n  }`;
    }

    return primitiveTypeToTs(type);
}

/**
 * Convert primitive JSON schema type to TypeScript
 */
function primitiveTypeToTs(type: string): string {
    switch (type) {
        case 'string': return 'string';
        case 'number': return 'number';
        case 'integer': return 'number';
        case 'boolean': return 'boolean';
        case 'null': return 'null';
        case 'array': return 'unknown[]';
        case 'object': return 'Record<string, unknown>';
        default: return 'unknown';
    }
}

/**
 * Update package.json with typesVersions and ensure types/index.d.ts is in files
 */
async function patchPackageJson(pkg: any, pkgPath: string, repoRoot: string): Promise<void> {
    let modified = false;

    // Ensure types/index.d.ts is in files array
    if (!pkg.files) {
        pkg.files = [];
    }

    const typesEntry = 'types/**/*.d.ts';
    if (!pkg.files.includes(typesEntry)) {
        pkg.files.push(typesEntry);
        modified = true;
        console.log(green(`‚úÖ [generate-types] Added "${typesEntry}" to package.json files`));
    }

    // Update typesVersions
    if (!pkg.typesVersions) {
        pkg.typesVersions = {};
    }

    if (!pkg.typesVersions['*']) {
        pkg.typesVersions['*'] = {};
    }

    const patterns = {
        'data/*': ['types/index.d.ts']
    };

    for (const [pattern, value] of Object.entries(patterns)) {
        const current = JSON.stringify(pkg.typesVersions['*'][pattern]);
        const expected = JSON.stringify(value);

        if (current !== expected) {
            pkg.typesVersions['*'][pattern] = value;
            modified = true;
            console.log(green(`‚úÖ [generate-types] Updated typesVersions["*"]["${pattern}"]`));
        }
    }

    // Remove old patterns that are no longer needed
    const oldPatterns = ['*', 'data/*.json', 'data/**/*.json'];
    for (const pattern of oldPatterns) {
        if (pkg.typesVersions['*'][pattern]) {
            delete pkg.typesVersions['*'][pattern];
            modified = true;
            console.log(yellow(`üóëÔ∏è  [generate-types] Removed old typesVersions pattern: "${pattern}"`));
        }
    }

    // Write package.json if modified
    if (modified) {
        await fs.writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\n', 'utf8');
        console.log(green(`‚úÖ [generate-types] Updated package.json`));
    } else {
        console.log(cyan(`‚úì  [generate-types] package.json already up to date`));
    }
}

/**
 * Run the script
 */
main().catch((error) => {
    console.error(red('‚ùå [generate-types] Fatal error:'));
    console.error(red(`   ${error instanceof Error ? error.message : String(error)}`));
    if (error instanceof Error && error.stack) {
        console.error(red(error.stack));
    }
    process.exit(1);
});
